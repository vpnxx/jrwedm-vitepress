import { onMounted as x, onUnmounted as I, ref as d, computed as h, toValue as b, watch as Y, onBeforeUnmount as S, useSlots as U, reactive as O, inject as D, toRefs as T, getCurrentInstance as j, Comment as k, Text as C } from "vue";
import { TinyColor as w } from "@ctrl/tinycolor";
import { generate as q } from "@ant-design/colors";
function K(e = Date.now(), n = "YYYY-MM-DD HH:mm:ss") {
  try {
    let t;
    if (typeof e == "number" || typeof e == "string") {
      if (t = new Date(e), isNaN(t.getTime()))
        throw new Error("Invalid date");
    } else
      t = e;
    const r = (l, o = 2) => String(l).padStart(o, "0"), s = (l) => {
      switch (l) {
        case "YYYY":
          return r(t.getFullYear());
        case "YY":
          return r(t.getFullYear()).slice(2, 4);
        case "MM":
          return r(t.getMonth() + 1);
        case "M":
          return String(t.getMonth() + 1);
        case "DD":
          return r(t.getDate());
        case "D":
          return String(t.getDate());
        case "HH":
          return r(t.getHours());
        case "H":
          return String(t.getHours());
        case "mm":
          return r(t.getMinutes());
        case "m":
          return String(t.getMinutes());
        case "ss":
          return r(t.getSeconds());
        case "s":
          return String(t.getSeconds());
        case "SSS":
          return r(t.getMilliseconds(), 3);
        default:
          return l;
      }
    };
    return n.replace(/(YYYY|YY|M{1,2}|D{1,2}|H{1,2}|m{1,2}|s{1,2}|SSS)/g, s);
  } catch (t) {
    return console.error("Error formatting date:", t), "";
  }
}
function X(e, n = 2, t = ",", r = ".", s, l) {
  typeof e != "number" && typeof e != "string" && console.warn("Expected value to be of type number or string"), typeof n != "number" && console.warn("Expected precision to be of type number");
  const o = Number(e);
  if (isNaN(o) || !isFinite(o))
    return "";
  if (o === 0)
    return o.toFixed(n);
  let c = o.toFixed(n);
  if (typeof t == "string" && t !== "") {
    const [i, u] = c.split(".");
    c = i.replace(/(\d)(?=(\d{3})+$)/g, "$1" + t) + (u ? r + u : "");
  }
  return (s || "") + c + (l || "");
}
function _(e, n = 0, t = !1) {
  let r = null;
  function s(o) {
    if (r || (r = o), o - r >= n) {
      try {
        e();
      } catch (i) {
        console.error("Error executing rafTimeout function:", i);
      }
      t && (r = o, l.id = requestAnimationFrame(s));
    } else
      l.id = requestAnimationFrame(s);
  }
  const l = {
    id: requestAnimationFrame(s)
  };
  return l;
}
function Q(e) {
  e && e.id && typeof e.id == "number" ? cancelAnimationFrame(e.id) : console.warn("cancelRaf received an invalid id:", e);
}
function B(e, n = 300) {
  let t = !0;
  return function(...r) {
    if (!t) return !1;
    t && (e(...r), t = !1, setTimeout(() => {
      t = !0;
    }, n));
  };
}
function P(e, n = 300) {
  let t = null;
  return function(...r) {
    t && clearTimeout(t), t = setTimeout(() => {
      e(...r);
    }, n);
  };
}
function ee(e, n) {
  if (Number.isNaN(e) || Number.isNaN(n))
    throw new Error("Both num1 and num2 must be valid numbers.");
  const t = e % 1 !== 0, r = n % 1 !== 0;
  if (!t && !r)
    return e + n;
  const s = String(e).split(".")[1] ?? "", l = String(n).split(".")[1] ?? "", o = Math.max(s.length, l.length), c = Math.pow(10, o), i = e.toFixed(o), u = n.toFixed(o);
  return (+i.replace(".", "") + +u.replace(".", "")) / c;
}
function te(e, n) {
  if (!e) {
    console.error("无效的 url");
    return;
  }
  const t = n || e.split("?")[0].split("/").pop() || "download";
  try {
    fetch(e).then((r) => {
      r.ok ? r.blob().then((s) => {
        const l = URL.createObjectURL(s), o = document.createElement("a");
        o.href = l, o.download = t, document.body.appendChild(o), o.click(), document.body.removeChild(o), URL.revokeObjectURL(l);
      }) : console.error("请求文件失败，状态码:", r.status);
    });
  } catch (r) {
    console.error("文件下载失败:", r);
  }
}
function ne() {
  const e = document.documentElement;
  e.classList.toggle("dark"), e.classList.contains("dark") ? e.style.colorScheme = "dark" : e.style.colorScheme = "light";
}
function z() {
  const e = d(!1), n = j();
  return n && x(() => {
    e.value = !0;
  }, n), e;
}
function H(e) {
  const n = z();
  return h(() => (n.value, !!e()));
}
function re(e, n, t) {
  x(() => e.addEventListener(n, t)), I(() => e.removeEventListener(n, t));
}
function oe(e, n, t = {}) {
  const r = H(() => window && "MutationObserver" in window), s = d(!1);
  let l;
  const o = h(() => {
    const a = b(e);
    return a ? Array.isArray(a) ? a.map((m) => b(m)).filter((m) => m) : [a] : [];
  }), c = () => {
    l && (l.disconnect(), l = void 0);
  }, i = () => {
    r.value && o.value.length && !s.value && (l = new MutationObserver(n), o.value.forEach((a) => l.observe(a, t)));
  };
  Y(
    () => o.value,
    () => {
      c(), i();
    },
    {
      immediate: !0,
      // 立即触发回调，以便初始状态也被观察
      flush: "post"
    }
  );
  const u = () => {
    s.value = !1, i();
  }, v = () => {
    s.value = !0, c();
  };
  return S(() => c()), {
    start: u,
    stop: v
  };
}
function se(e = window, n = 0, t, r) {
  const s = d(0), l = d(0), o = d(0), c = d(0), i = d(!1), u = d(!1), v = d(!1), a = d(!1), m = d(!1), E = d(0), y = d(0);
  function N(f) {
    i.value = !0;
    const g = f.target.documentElement ?? f.target;
    s.value = g.scrollLeft, o.value = g.scrollTop, u.value = s.value < E.value, v.value = s.value > E.value, a.value = o.value < y.value, m.value = o.value > y.value, E.value = s.value, y.value = o.value, M(f), t && t(f);
  }
  const A = B(N, n);
  function V(f) {
    i.value && (i.value = !1, u.value = !1, v.value = !1, a.value = !1, m.value = !1, r && r(f));
  }
  const M = P(V, n + 200), F = h(() => {
    const f = b(e);
    return f || null;
  });
  Y(
    () => F.value,
    (f, g) => {
      if (g && R(g), f) {
        const p = f?.document?.documentElement || f?.documentElement || f;
        l.value = p.scrollWidth - p.clientWidth, c.value = p.scrollHeight - p.clientHeight, p.addEventListener("scroll", A), p.addEventListener("scrollend", M);
      }
    },
    {
      immediate: !0,
      flush: "post"
    }
  );
  function R(f) {
    const g = f?.document?.documentElement || f?.documentElement || f;
    g.removeEventListener("scroll", A), g.removeEventListener("scrollend", M);
  }
  return S(() => R(F.value)), { x: s, xScrollMax: l, y: o, yScrollMax: c, isScrolling: i, left: u, right: v, top: a, bottom: m };
}
function le() {
  const e = d(0), n = d(0);
  let t = performance.now();
  const r = 10, s = (l) => {
    if (n.value++, n.value >= r) {
      const o = l - t;
      e.value = Math.round(1e3 / (o / r)), t = l, n.value = 0;
    }
    requestAnimationFrame(s);
  };
  return requestAnimationFrame(s), { fps: e };
}
function ue(e) {
  if (!e || typeof e != "string" || e.trim() === "")
    throw new Error("Invalid mediaQuery parameter. It must be a non-empty string.");
  const n = d(window && window.matchMedia(e).matches), t = window.matchMedia(e), r = (s) => {
    n.value = s.matches;
  };
  return x(() => {
    t.addEventListener("change", r);
  }), S(() => {
    t.removeEventListener("change", r);
  }), { match: n };
}
function ce(e, n, t = {}) {
  const r = H(() => window && "ResizeObserver" in window);
  let s;
  const l = d(!1), o = h(() => {
    const a = b(e);
    return a ? Array.isArray(a) ? a.map((m) => b(m)).filter((m) => m) : [a] : [];
  }), c = () => {
    s && (s.disconnect(), s = void 0);
  }, i = () => {
    r.value && o.value.length && !l.value && (s = new ResizeObserver(n), o.value.forEach((a) => s.observe(a, t)));
  };
  Y(
    () => o.value,
    () => {
      c(), i();
    },
    {
      immediate: !0,
      // 立即触发回调，以便初始状态也被观察
      flush: "post"
    }
  );
  const u = () => {
    l.value = !1, i();
  }, v = () => {
    l.value = !0, c();
  };
  return S(() => c()), {
    start: u,
    stop: v
  };
}
function ae(e) {
  const n = U(), t = (r) => {
    const s = n[r]?.(), l = (o) => {
      if (o.type === k || Array.isArray(o.children) && !o.children.length)
        return !1;
      if (o.type !== C)
        return !0;
      if (typeof o.children == "string")
        return o.children.trim() !== "";
    };
    return s && s?.length ? s.some((c) => l(c)) : !1;
  };
  if (Array.isArray(e)) {
    const r = O({});
    return e.forEach((s) => {
      const l = h(() => t(s));
      r[s] = l;
    }), r;
  } else
    return h(() => t(e));
}
function ie(e) {
  const n = G("#1677ff"), t = D("common", O({ colorPalettes: n, shadowColor: W(n[0]) })), r = D("components", null);
  return r !== null && e in r && r[e].colorPalettes.length ? T(r[e]) : T(t);
}
function G(e) {
  return q(e);
}
function L(e) {
  return e >= 0 && e <= 255;
}
function W(e, n = "#ffffff") {
  const { r: t, g: r, b: s, a: l } = new w(e).toRgb();
  if (l < 1) return e;
  const { r: o, g: c, b: i } = new w(n).toRgb();
  for (let u = 0.01; u <= 1; u += 0.01) {
    const v = Math.round((t - o * (1 - u)) / u), a = Math.round((r - c * (1 - u)) / u), m = Math.round((s - i * (1 - u)) / u);
    if (L(v) && L(a) && L(m))
      return new w({ r: v, g: a, b: m, a: Math.round(u * 100) / 100 }).toRgbString();
  }
  return new w({ r: t, g: r, b: s, a: 1 }).toRgbString();
}
function fe(e) {
  const n = d(!1);
  try {
    const t = {
      get [e]() {
        return n.value = !0, !1;
      }
    };
    window.addEventListener("test", () => null, t), window.removeEventListener("test", () => null, t);
  } catch {
    n.value = !1;
  }
  return { isSupported: n };
}
export {
  ee as add,
  Q as cancelRaf,
  K as dateFormat,
  P as debounce,
  te as downloadFile,
  X as formatNumber,
  W as getAlphaColor,
  G as getColorPalettes,
  _ as rafTimeout,
  B as throttle,
  ne as toggleDark,
  re as useEventListener,
  le as useFps,
  ie as useInject,
  ue as useMediaQuery,
  z as useMounted,
  oe as useMutationObserver,
  fe as useOptionsSupported,
  ce as useResizeObserver,
  se as useScroll,
  ae as useSlotsExist,
  H as useSupported
};
